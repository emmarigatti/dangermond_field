library(tidyr)
library(dplyr)
library(ggplot2)
library(lubridate)
library(zoo)
series_leaf <- readRDS("/Users/emmarigatti/Desktop/GitHub/pv_curves/csvs/sept2025/tlp_summary_leaf.rds")
series_stem <- readRDS("/Users/emmarigatti/Desktop/GitHub/pv_curves/csvs/sept2025/tlp_summary_stem.rds")
leaf_9 <- series_leaf[[1]]
plot(leaf_9$theta, leaf_9$water_pot)
print(series_leaf)
for (nm in names(series_leaf)) {
assign(paste0("series_leaf_", nm), series_leaf[[nm]])
}
for (nm in names(series_stem)) {
assign(paste0("series_stem_", nm), series_stem[[nm]])
}
View(series_leaf_100)
tlp_leaf <- read.csv("/Users/emmarigatti/Desktop/GitHub/pv_curves/csvs/sept2025/tlp_summary_leaf.csv")
tlp_leaf <- tlp_leaf[,-1]
tlp_leaf[5, 1] <- "098"
tlp_stem <- read.csv("/Users/emmarigatti/Desktop/GitHub/pv_curves/csvs/sept2025/tlp_summary_stem.csv")
tlp_stem <- tlp_stem[,-1]
tlp_stem[5, 1] <- "098"
View(tlp_leaf)
library(tidyr)
library(dplyr)
library(ggplot2)
library(lubridate)
library(zoo)
stopifnot(all(c("Tree", "TLP") %in% names(tlp_leaf)))
tlp_lookup <- tlp_leaf %>%
mutate(Tree = as.character(Tree)) %>%
select(Tree, TLP)
fit_one_tree <- function(tree_df, tlp_value) {
tree_df <- tree_df %>%
filter(is.finite(theta), is.finite(water_pot)) %>%
arrange(theta)
if (nrow(tree_df) < 5 || !is.finite(tlp_value)) return(NULL)
a0 <- max(tree_df$water_pot, na.rm = TRUE)   # near 0 MPa (least negative)
b0 <- min(tree_df$water_pot, na.rm = TRUE)   # most negative MPa
x0 <- tlp_value
# Try several starting slopes for k; your original was 100, which can be too aggressive.
k_grid <- c(100, 50, 20, 10, 5)
for (kk in k_grid) {
vals <- list(a = a0, b = b0, k = kk, x0 = x0)
fit <- try(nls(
water_pot ~ b + (a - b) / (1 + exp(k * (x0 - theta))),
data    = tree_df,
start   = vals,
control = nls.control(maxiter = 500, warnOnly = TRUE)
), silent = TRUE)
if (!inherits(fit, "try-error")) return(fit)
}
NULL
}
# --- 3) Decide on a common theta grid where all trees have support ---
theta_min <- max(map_dbl(series_leaf, ~min(.$theta, na.rm = TRUE)))
theta_max <- min(map_dbl(series_leaf, ~max(.$theta, na.rm = TRUE)))
library(purrr)
fit_one_tree <- function(tree_df, tlp_value) {
tree_df <- tree_df %>%
filter(is.finite(theta), is.finite(water_pot)) %>%
arrange(theta)
if (nrow(tree_df) < 5 || !is.finite(tlp_value)) return(NULL)
a0 <- max(tree_df$water_pot, na.rm = TRUE)   # near 0 MPa (least negative)
b0 <- min(tree_df$water_pot, na.rm = TRUE)   # most negative MPa
x0 <- tlp_value
# Try several starting slopes for k; your original was 100, which can be too aggressive.
k_grid <- c(100, 50, 20, 10, 5)
for (kk in k_grid) {
vals <- list(a = a0, b = b0, k = kk, x0 = x0)
fit <- try(nls(
water_pot ~ b + (a - b) / (1 + exp(k * (x0 - theta))),
data    = tree_df,
start   = vals,
control = nls.control(maxiter = 500, warnOnly = TRUE)
), silent = TRUE)
if (!inherits(fit, "try-error")) return(fit)
}
NULL
}
# --- 3) Decide on a common theta grid where all trees have support ---
theta_min <- max(map_dbl(series_leaf, ~min(.$theta, na.rm = TRUE)))
theta_max <- min(map_dbl(series_leaf, ~max(.$theta, na.rm = TRUE)))
if (!is.finite(theta_min) || !is.finite(theta_max) || theta_min >= theta_max) {
stop("Theta ranges do not overlap across trees; cannot build a common grid.")
}
